


**Leetcode 22: Generate Parentheses**, a classic **backtracking + recursion** problem.

Here are **all the main approaches and strategies** you can use to solve it — no code, just clear hints and high-level thoughts.

---

### ✅ **1. Backtracking (Most Common)**

**Approach:**

* Start with an empty string.
* At each step, you can add:

  * `'('` if the number of `'('` used so far is less than `n`
  * `')'` if the number of `')'` is less than `'('` used so far
* Recurse until the string reaches length `2 * n`.

🧠 Think of it like building the tree of possibilities and pruning invalid branches early.

---

### ✅ **2. BFS (Queue-based Iterative)**

**Approach:**

* Use a queue to store partial strings and their counts of open/close parentheses.
* Start from `("", 0, 0)` (empty string, 0 open, 0 close)
* Add new states to the queue by appending `'('` or `')'` when valid.
* When length reaches `2 * n`, it's a valid result.

🧠 Good if you're trying to avoid recursion and want an iterative solution.

---

### ✅ **3. Dynamic Programming (DP with Memorization)**

**Approach:**

* Let `generate(n)` be the list of combinations for `n` pairs.
* For each `i` from `0` to `n-1`, do:

  * Combine `(` + *generate(i)* + `)` + *generate(n - i - 1)*
* This builds solutions from smaller subproblems.

🧠 This is a bit tricky to reason through but elegant once you get it.

---

### ✅ **4. Catalan Number Insight (Mathematical)**

**Approach:**

* You don’t generate directly, but understand that the number of valid combinations is the `n`th Catalan number.
* Use this for optimization bounds or dynamic programming.

🧠 The Catalan number appears naturally when counting valid parentheses.

---

### 📝 Summary Table:

| Method         | Type         | Notes                                 |
| -------------- | ------------ | ------------------------------------- |
| Backtracking   | Recursive    | Cleanest, most common                 |
| BFS            | Iterative    | Good for avoiding recursion           |
| DP with Memo   | Recursive/DP | Build solutions from subparts         |
| Math (Catalan) | Analytical   | Use for validation or limits, not gen |


---

#  **1. DP with Memo**
We build valid combinations for `n` pairs by **combining results of smaller subproblems**.

Let’s define:

```text
dp[n] = all valid combinations of well-formed parentheses using n pairs
```

---

### 🪜 Step-by-Step:

#### ✅ Step 1: Define Base Case

* `dp[0] = [""]`
  → There's 1 valid combination of 0 pairs: an empty string.

---

#### ✅ Step 2: Build Up dp\[n] from dp\[0] to dp\[n-1]

For `dp[n]`, the logic is:

For each `i` from `0` to `n - 1`:

```text
Wrap dp[i] with a pair of parentheses → "(" + dp[i] + ")"
Then append all combinations from dp[n - i - 1] after that.
```

**In formula:**

```
dp[n] = for i in 0 to n-1:
          for each left in dp[i]:
            for each right in dp[n-i-1]:
              dp[n].push_back("(" + left + ")" + right)
```

---

### 📘 Example: `n = 3`

Build up from small cases:

* `dp[0] = [""]`

* `dp[1] = ["()"]`

* `dp[2]`:

  * i = 0: "(" + dp\[0] + ")" + dp\[1] → "()" + "()" = "()()"
  * i = 1: "(" + dp\[1] + ")" + dp\[0] → "(" + "()" + ")" = "(())"
    → `dp[2] = ["()()", "(())"]`

* `dp[3]`:

  * i = 0: "(" + dp\[0] + ")" + dp\[2] → "()" + \["()()", "(())"] → \["()()()", "()(())"]
  * i = 1: "(" + dp\[1] + ")" + dp\[1] → "()" + "()" → \["(())()"]
  * i = 2: "(" + dp\[2] + ")" + dp\[0] → \["(()())", "((()))"]

  → Total:

  ```
  dp[3] = ["()()()", "()(())", "(())()", "(()())", "((()))"]
  ```

---

### 🧠 Why It Works:

You're systematically creating every possible structure of valid parentheses by:

* Wrapping inner structures in `()`
* Appending outer ones
* Ensuring correctness due to the DP's structure (you only build from smaller, already-valid results)

---

### ⏱ Time Complexity:

This approach also generates **Catalan(n)** combinations, which is exponential:
**O(4^n / √n)** — same as backtracking.

---

# **2. Using BFS(QUEUE)**
```C++
 vector<string> generateParenthesis(int n) {
        vector<string> result;
        queue<tuple<string, int, int>> q; // (current_string, open_count, close_count)
        q.push({"", 0, 0});
        
        while (!q.empty()) {
            auto [curr, open, close] = q.front();
            q.pop();
            
            if (curr.length() == 2 * n) {
                result.push_back(curr);
                continue;
            }
            
            // add '(' if we can
            if (open < n) {
                q.push({curr + '(', open + 1, close});
            }
            // add ')' if it would not exceed the number of '('
            if (close < open) {
                q.push({curr + ')', open, close + 1});
            }
        }
        
        return result;
    }
```

 Let's now walk through the **corrected and complete BFS expansion** for **n = 3**, including **queue state** and correct rules:

---

## 🎯 Goal:

Generate all valid strings of **3 pairs of parentheses** (`n = 3`) using **BFS**.

---

## 🔧 Rules:

At each step:

* ✅ You can add `'('` if `open < n`
* ✅ You can add `')'` if `close < open`

Each state in queue:

```text
(string_so_far, open_count, close_count)
```

---

## 🟢 Level-by-Level BFS with Queue States

### Level 0:

* Queue: `[("", 0, 0)]`

---

### Level 1:

Dequeue: `("", 0, 0)`

* Add `'('` → `"("`, open = 1, close = 0

✅ Queue:
`[("(", 1, 0)]`

---

### Level 2:

Dequeue: `("(", 1, 0)`

* Add `'('` → `"(("`, open = 2, close = 0
* Add `')'` → `"()"`, open = 1, close = 1 ✅ `close < open`

✅ Queue:
`["((", 2, 0]`, `["()", 1, 1]`

---

### Level 3:

Dequeue: `"((", 2, 0)`

* Add `'('` → `"((("`, 3, 0
* Add `')'` → `"(()"`, 2, 1

Dequeue: `"()", 1, 1`

* Add `'('` → `"()("`, 2, 1

✅ Queue:
`["(((", 3, 0]`, `["(()", 2, 1]`, `["()(", 2, 1]`

---

### Level 4:

Dequeue: `"(((", 3, 0`

* Add `')'` → `"((()"`, 3, 1

Dequeue: `"(()", 2, 1`

* Add `'('` → `"(()("`, 3, 1
* Add `')'` → `"(())"`, 2, 2

Dequeue: `"()("`, 2, 1\`

* Add `'('` → `"()(("`, 3, 1
* Add `')'` → `"()()"`, 2, 2

✅ Queue:
`["((()", 3, 1]`, `["(()(", 3, 1]`, `["(())", 2, 2]`, `["()((", 3, 1]`, `["()()", 2, 2]`

---

### Level 5:

Dequeue: `"((()", 3, 1`

* Add `')'` → `"((())"`, 3, 2

Dequeue: `"(()(", 3, 1`

* Add `')'` → `"(()())"`, 3, 2

Dequeue: `"(())", 2, 2`

* Add `'('` → `"(())("`, 3, 2

Dequeue: `"()((", 3, 1`

* Add `')'` → `"()(()"`, 3, 2

Dequeue: `"()()", 2, 2`

* Add `'('` → `"()()("`, 3, 2

✅ Queue:
`["((())", 3, 2]`, `["(()())", 3, 2]`, `["(())(", 3, 2]`, `["()(()", 3, 2]`, `["()()(", 3, 2]`

---

### Level 6:

All have open = 3 → only `')'` can be added

* `"((())"` → `((()))` ✅
* `"(()())"` → `(()())` ✅
* `"(())("` → `(())()` ✅
* `"()(()"` → `()(())` ✅
* `"()()("` → `()()()` ✅

---

## ✅ Final Output for `n = 3`:

```cpp
[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]
```

---

## 🔚 Summary

### How queue simulates recursion:

* It stores all "partial" valid states
* Expands only when the state obeys the rules:

  * `'('` only if `open < n`
  * `')'` only if `close < open`
* Final strings are added when length == `2 * n`

