


**Leetcode 22: Generate Parentheses**, a classic **backtracking + recursion** problem.

Here are **all the main approaches and strategies** you can use to solve it â€” no code, just clear hints and high-level thoughts.

---

### âœ… **1. Backtracking (Most Common)**

**Approach:**

* Start with an empty string.
* At each step, you can add:

  * `'('` if the number of `'('` used so far is less than `n`
  * `')'` if the number of `')'` is less than `'('` used so far
* Recurse until the string reaches length `2 * n`.

ğŸ§  Think of it like building the tree of possibilities and pruning invalid branches early.

---

### âœ… **2. BFS (Queue-based Iterative)**

**Approach:**

* Use a queue to store partial strings and their counts of open/close parentheses.
* Start from `("", 0, 0)` (empty string, 0 open, 0 close)
* Add new states to the queue by appending `'('` or `')'` when valid.
* When length reaches `2 * n`, it's a valid result.

ğŸ§  Good if you're trying to avoid recursion and want an iterative solution.

---

### âœ… **3. Dynamic Programming (DP with Memorization)**

**Approach:**

* Let `generate(n)` be the list of combinations for `n` pairs.
* For each `i` from `0` to `n-1`, do:

  * Combine `(` + *generate(i)* + `)` + *generate(n - i - 1)*
* This builds solutions from smaller subproblems.

ğŸ§  This is a bit tricky to reason through but elegant once you get it.

---

### âœ… **4. Catalan Number Insight (Mathematical)**

**Approach:**

* You donâ€™t generate directly, but understand that the number of valid combinations is the `n`th Catalan number.
* Use this for optimization bounds or dynamic programming.

ğŸ§  The Catalan number appears naturally when counting valid parentheses.

---

### ğŸ“ Summary Table:

| Method         | Type         | Notes                                 |
| -------------- | ------------ | ------------------------------------- |
| Backtracking   | Recursive    | Cleanest, most common                 |
| BFS            | Iterative    | Good for avoiding recursion           |
| DP with Memo   | Recursive/DP | Build solutions from subparts         |
| Math (Catalan) | Analytical   | Use for validation or limits, not gen |


---

#  **1. DP with Memo**
We build valid combinations for `n` pairs by **combining results of smaller subproblems**.

Letâ€™s define:

```text
dp[n] = all valid combinations of well-formed parentheses using n pairs
```

---

### ğŸªœ Step-by-Step:

#### âœ… Step 1: Define Base Case

* `dp[0] = [""]`
  â†’ There's 1 valid combination of 0 pairs: an empty string.

---

#### âœ… Step 2: Build Up dp\[n] from dp\[0] to dp\[n-1]

For `dp[n]`, the logic is:

For each `i` from `0` to `n - 1`:

```text
Wrap dp[i] with a pair of parentheses â†’ "(" + dp[i] + ")"
Then append all combinations from dp[n - i - 1] after that.
```

**In formula:**

```
dp[n] = for i in 0 to n-1:
          for each left in dp[i]:
            for each right in dp[n-i-1]:
              dp[n].push_back("(" + left + ")" + right)
```

---

### ğŸ“˜ Example: `n = 3`

Build up from small cases:

* `dp[0] = [""]`

* `dp[1] = ["()"]`

* `dp[2]`:

  * i = 0: "(" + dp\[0] + ")" + dp\[1] â†’ "()" + "()" = "()()"
  * i = 1: "(" + dp\[1] + ")" + dp\[0] â†’ "(" + "()" + ")" = "(())"
    â†’ `dp[2] = ["()()", "(())"]`

* `dp[3]`:

  * i = 0: "(" + dp\[0] + ")" + dp\[2] â†’ "()" + \["()()", "(())"] â†’ \["()()()", "()(())"]
  * i = 1: "(" + dp\[1] + ")" + dp\[1] â†’ "()" + "()" â†’ \["(())()"]
  * i = 2: "(" + dp\[2] + ")" + dp\[0] â†’ \["(()())", "((()))"]

  â†’ Total:

  ```
  dp[3] = ["()()()", "()(())", "(())()", "(()())", "((()))"]
  ```

---

### ğŸ§  Why It Works:

You're systematically creating every possible structure of valid parentheses by:

* Wrapping inner structures in `()`
* Appending outer ones
* Ensuring correctness due to the DP's structure (you only build from smaller, already-valid results)

---

### â± Time Complexity:

This approach also generates **Catalan(n)** combinations, which is exponential:
**O(4^n / âˆšn)** â€” same as backtracking.

---

# **2. Using BFS(QUEUE)**
```C++
 vector<string> generateParenthesis(int n) {
        vector<string> result;
        queue<tuple<string, int, int>> q; // (current_string, open_count, close_count)
        q.push({"", 0, 0});
        
        while (!q.empty()) {
            auto [curr, open, close] = q.front();
            q.pop();
            
            if (curr.length() == 2 * n) {
                result.push_back(curr);
                continue;
            }
            
            // add '(' if we can
            if (open < n) {
                q.push({curr + '(', open + 1, close});
            }
            // add ')' if it would not exceed the number of '('
            if (close < open) {
                q.push({curr + ')', open, close + 1});
            }
        }
        
        return result;
    }
```

 Let's now walk through the **corrected and complete BFS expansion** for **n = 3**, including **queue state** and correct rules:

---

## ğŸ¯ Goal:

Generate all valid strings of **3 pairs of parentheses** (`n = 3`) using **BFS**.

---

## ğŸ”§ Rules:

At each step:

* âœ… You can add `'('` if `open < n`
* âœ… You can add `')'` if `close < open`

Each state in queue:

```text
(string_so_far, open_count, close_count)
```

---

## ğŸŸ¢ Level-by-Level BFS with Queue States

### Level 0:

* Queue: `[("", 0, 0)]`

---

### Level 1:

Dequeue: `("", 0, 0)`

* Add `'('` â†’ `"("`, open = 1, close = 0

âœ… Queue:
`[("(", 1, 0)]`

---

### Level 2:

Dequeue: `("(", 1, 0)`

* Add `'('` â†’ `"(("`, open = 2, close = 0
* Add `')'` â†’ `"()"`, open = 1, close = 1 âœ… `close < open`

âœ… Queue:
`["((", 2, 0]`, `["()", 1, 1]`

---

### Level 3:

Dequeue: `"((", 2, 0)`

* Add `'('` â†’ `"((("`, 3, 0
* Add `')'` â†’ `"(()"`, 2, 1

Dequeue: `"()", 1, 1`

* Add `'('` â†’ `"()("`, 2, 1

âœ… Queue:
`["(((", 3, 0]`, `["(()", 2, 1]`, `["()(", 2, 1]`

---

### Level 4:

Dequeue: `"(((", 3, 0`

* Add `')'` â†’ `"((()"`, 3, 1

Dequeue: `"(()", 2, 1`

* Add `'('` â†’ `"(()("`, 3, 1
* Add `')'` â†’ `"(())"`, 2, 2

Dequeue: `"()("`, 2, 1\`

* Add `'('` â†’ `"()(("`, 3, 1
* Add `')'` â†’ `"()()"`, 2, 2

âœ… Queue:
`["((()", 3, 1]`, `["(()(", 3, 1]`, `["(())", 2, 2]`, `["()((", 3, 1]`, `["()()", 2, 2]`

---

### Level 5:

Dequeue: `"((()", 3, 1`

* Add `')'` â†’ `"((())"`, 3, 2

Dequeue: `"(()(", 3, 1`

* Add `')'` â†’ `"(()())"`, 3, 2

Dequeue: `"(())", 2, 2`

* Add `'('` â†’ `"(())("`, 3, 2

Dequeue: `"()((", 3, 1`

* Add `')'` â†’ `"()(()"`, 3, 2

Dequeue: `"()()", 2, 2`

* Add `'('` â†’ `"()()("`, 3, 2

âœ… Queue:
`["((())", 3, 2]`, `["(()())", 3, 2]`, `["(())(", 3, 2]`, `["()(()", 3, 2]`, `["()()(", 3, 2]`

---

### Level 6:

All have open = 3 â†’ only `')'` can be added

* `"((())"` â†’ `((()))` âœ…
* `"(()())"` â†’ `(()())` âœ…
* `"(())("` â†’ `(())()` âœ…
* `"()(()"` â†’ `()(())` âœ…
* `"()()("` â†’ `()()()` âœ…

---

## âœ… Final Output for `n = 3`:

```cpp
[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]
```

---

## ğŸ”š Summary

### How queue simulates recursion:

* It stores all "partial" valid states
* Expands only when the state obeys the rules:

  * `'('` only if `open < n`
  * `')'` only if `close < open`
* Final strings are added when length == `2 * n`

